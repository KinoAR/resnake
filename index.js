// Generated by BUCKLESCRIPT VERSION 4.0.6, PLEASE EDIT WITH CARE
'use strict';

var List = require("bsb-native/lib/js/list.js");
var $$Array = require("bsb-native/lib/js/array.js");
var Curry = require("bsb-native/lib/js/curry.js");
var Caml_obj = require("bsb-native/lib/js/caml_obj.js");
var Caml_array = require("bsb-native/lib/js/caml_array.js");
var Caml_int32 = require("bsb-native/lib/js/caml_int32.js");
var Pervasives = require("bsb-native/lib/js/pervasives.js");
var Reprocessing = require("Reprocessing//Users/kinor/Documents/development/reasonml/re-snake/node_modules/reprocessing/lib/js/src/Reprocessing.js");
var Reprocessing_Env = require("Reprocessing//Users/kinor/Documents/development/reasonml/re-snake/node_modules/reprocessing/lib/js/src/Reprocessing_Env.js");
var Reprocessing_Draw = require("Reprocessing//Users/kinor/Documents/development/reasonml/re-snake/node_modules/reprocessing/lib/js/src/Reprocessing_Draw.js");
var Reprocessing_Utils = require("Reprocessing//Users/kinor/Documents/development/reasonml/re-snake/node_modules/reprocessing/lib/js/src/Reprocessing_Utils.js");
var Reprocessing_Constants = require("Reprocessing//Users/kinor/Documents/development/reasonml/re-snake/node_modules/reprocessing/lib/js/src/Reprocessing_Constants.js");

var gridSize = /* tuple */[
  100,
  100
];

var bodySize = 7;

var obstacleAmount = Math.floor(10000 * 0.01) | 0;

var headColor = Reprocessing_Utils.color(255, 255, 255, 255);

var obstacleColor = Reprocessing_Utils.color(0, 255, 0, 255);

var textColor = Reprocessing_Utils.color(255, 255, 255, 255);

function clamp(min, max, num) {
  var match = Caml_obj.caml_lessequal(num, min);
  if (match) {
    return min;
  } else {
    var match$1 = Caml_obj.caml_greaterequal(num, max);
    if (match$1) {
      return max;
    } else {
      return num;
    }
  }
}

function getListElement(index, list) {
  return Caml_array.caml_array_get($$Array.of_list(list), index);
}

function hitBoundary(x, y, env) {
  var width = Reprocessing_Env.width(env);
  var height = Reprocessing_Env.height(env);
  if (x >= (width - bodySize | 0) || x <= bodySize) {
    return /* HitSides */1;
  } else if (y >= (height - bodySize | 0) || y <= bodySize) {
    return /* HitCeiling */0;
  } else {
    return /* HitNoBoundary */3;
  }
}

function printPosition(position) {
  console.log("(" + (String(position[0]) + ("," + (String(position[1]) + ")"))));
  return /* () */0;
}

function printGrid(grid) {
  return $$Array.iter((function (el) {
                return $$Array.iter(printPosition, el);
              }), grid);
}

function getGridPosition(x, y, grid) {
  return Caml_array.caml_array_get(Caml_array.caml_array_get(grid, x), y);
}

function offsetPosition(offX, offY, position) {
  return /* tuple */[
          position[0] + offX | 0,
          position[1] + offY | 0
        ];
}

function getGridPositionOffset(grid, x, y, offX, offY) {
  return offsetPosition(offX, offY, getGridPosition(x, y, grid));
}

function randomGridPosition(minX, minY, maxX, maxY) {
  var x = Reprocessing_Utils.random(minX, maxX);
  var y = Reprocessing_Utils.random(minY, maxY);
  return /* tuple */[
          x,
          y
        ];
}

function randomGridPositionReal(minX, minY, maxX, maxY, grid) {
  var match = randomGridPosition(minX, minY, maxX, maxY);
  return getGridPosition(match[0], match[1], grid);
}

function randomFreeGridPosition(minX, minY, maxX, maxY, positionList) {
  while(true) {
    var randomPosition = randomGridPosition(minX, minY, maxX, maxY);
    var match_ = List.exists((function(randomPosition){
        return function (position) {
          return Caml_obj.caml_equal(randomPosition, position);
        }
        }(randomPosition)), positionList);
    if (match_ === false) {
      return randomPosition;
    } else {
      continue ;
    }
  };
}

function createGrid(gridSize, width, height) {
  var gridLength = gridSize[1];
  var gridWidth = gridSize[0];
  var length = Caml_int32.div(height, gridLength);
  var width$1 = Caml_int32.div(width, gridWidth);
  return $$Array.mapi((function (x, _) {
                return $$Array.mapi((function (y, _) {
                              return /* tuple */[
                                      Caml_int32.imul(x, width$1),
                                      Caml_int32.imul(y, length)
                                    ];
                            }), Caml_array.caml_make_vect(gridLength, ""));
              }), Caml_array.caml_make_vect(gridWidth, ""));
}

var grid = createGrid(gridSize, 700, 700);

function setup(env) {
  var position = randomGridPosition(1, 1, 99, 99);
  var obstaclePositions = $$Array.to_list($$Array.map((function () {
              return randomGridPosition(1, 1, 99, 99);
            }), Caml_array.caml_make_vect(obstacleAmount, "")));
  var foodPosition = randomFreeGridPosition(1, 1, 99, 99, obstaclePositions);
  Reprocessing_Env.size(700, 700, env);
  return /* record */[
          /* score */0,
          /* highScore */0,
          /* direction : None */4,
          /* level */1,
          /* snake : :: */[
            position,
            /* [] */0
          ],
          /* snakePrevious : :: */[
            position,
            /* [] */0
          ],
          /* foodPosition */foodPosition,
          /* obstacles */obstaclePositions,
          /* running : Alive */0
        ];
}

function snakeDirection(direction, env) {
  if (Reprocessing_Env.key(/* Right */51, env)) {
    return /* Right */1;
  } else if (Reprocessing_Env.key(/* Left */52, env)) {
    return /* Left */0;
  } else if (Reprocessing_Env.key(/* Down */53, env)) {
    return /* Down */2;
  } else if (Reprocessing_Env.key(/* Up */54, env)) {
    return /* Up */3;
  } else {
    return direction;
  }
}

function moveSnakeGrid(gridPos, direction) {
  var y = gridPos[1];
  var x = gridPos[0];
  var match;
  switch (direction) {
    case 0 : 
        match = /* tuple */[
          x - 1 | 0,
          y
        ];
        break;
    case 1 : 
        match = /* tuple */[
          x + 1 | 0,
          y
        ];
        break;
    case 2 : 
        match = /* tuple */[
          x,
          y + 1 | 0
        ];
        break;
    case 3 : 
        match = /* tuple */[
          x,
          y - 1 | 0
        ];
        break;
    case 4 : 
        match = /* tuple */[
          x,
          y
        ];
        break;
    
  }
  var x$1 = clamp(0, 99, match[0]);
  var y$1 = clamp(0, 99, match[1]);
  return /* tuple */[
          x$1,
          y$1
        ];
}

function directionMoved(gridPos, gridPos2) {
  var match = gridPos2[0] - gridPos[0] | 0;
  var match$1 = gridPos2[1] - gridPos[1] | 0;
  var switcher = match + 1 | 0;
  if (switcher > 2 || switcher < 0) {
    return /* None */4;
  } else {
    switch (switcher) {
      case 0 : 
          if (match$1 !== 0) {
            return /* None */4;
          } else {
            return /* Left */0;
          }
      case 1 : 
          var switcher$1 = match$1 + 1 | 0;
          if (switcher$1 > 2 || switcher$1 < 0) {
            return /* None */4;
          } else {
            switch (switcher$1) {
              case 0 : 
                  return /* Up */3;
              case 1 : 
                  return /* None */4;
              case 2 : 
                  return /* Down */2;
              
            }
          }
      case 2 : 
          if (match$1 !== 0) {
            return /* None */4;
          } else {
            return /* Right */1;
          }
      
    }
  }
}

function printRunning(running) {
  switch (running) {
    case 0 : 
        return "Alive";
    case 1 : 
        return "Dead";
    case 2 : 
        return "Restart";
    
  }
}

function drawFood(pos, grid, color, env) {
  var halfFoodSize = bodySize / 2 | 0;
  var match = getGridPositionOffset(grid, pos[0], pos[1], halfFoodSize, halfFoodSize);
  Reprocessing_Draw.fill(color, env);
  return Reprocessing_Draw.ellipse(/* tuple */[
              match[0],
              match[1]
            ], halfFoodSize, halfFoodSize, env);
}

function drawObstacle(pos, grid, color, env) {
  Reprocessing_Draw.fill(color, env);
  return Reprocessing_Draw.rect(getGridPositionOffset(grid, pos[0], pos[1], 0, 0), bodySize, bodySize, env);
}

function drawBoundary(env) {
  var width = Reprocessing_Env.width(env);
  var height = Reprocessing_Env.height(env);
  Reprocessing_Draw.fill(Reprocessing_Constants.black, env);
  Reprocessing_Draw.rect(/* tuple */[
        0,
        0
      ], width, bodySize, env);
  Reprocessing_Draw.rect(/* tuple */[
        0,
        0
      ], bodySize, height, env);
  Reprocessing_Draw.rect(/* tuple */[
        0,
        height - bodySize | 0
      ], width, bodySize, env);
  return Reprocessing_Draw.rect(/* tuple */[
              width - bodySize | 0,
              0
            ], bodySize, height, env);
}

function drawSnake(pos, grid, color, env) {
  var match = getGridPositionOffset(grid, pos[0], pos[1], 0, 0);
  Reprocessing_Draw.fill(color, env);
  return Reprocessing_Draw.rect(/* tuple */[
              match[0],
              match[1]
            ], bodySize, bodySize, env);
}

function drawCenteredText(color, text, y, env) {
  Reprocessing_Draw.fill(color, env);
  var width = Reprocessing_Draw.textWidth(undefined, text, env);
  var center = (Reprocessing_Env.width(env) / 2 | 0) - width | 0;
  return Reprocessing_Draw.text(undefined, text, /* tuple */[
              center,
              y
            ], env);
}

function normalize(param) {
  var y = param[1];
  var x = param[0];
  var match = x !== 0;
  var normX = match ? Caml_int32.div(Pervasives.abs(x), x) : x;
  var match$1 = y !== 0;
  var normY = match$1 ? Caml_int32.div(Pervasives.abs(y), y) : y;
  return /* tuple */[
          normX,
          normY
        ];
}

function drawCenteredSysText(param, param$1, param$2) {
  return drawCenteredText(textColor, param, param$1, param$2);
}

function intersectRectCircleI(rectPos, rectW, rectH, circlePos, circleRad) {
  return Reprocessing_Utils.intersectRectCircle(/* tuple */[
              rectPos[0],
              rectPos[1]
            ], rectW, rectH, /* tuple */[
              circlePos[0],
              circlePos[1]
            ], circleRad);
}

function intersectRectRectI(rectPos, rectW, rectH, rect2Pos, rect2W, rect2H) {
  return Reprocessing_Utils.intersectRectRect(/* tuple */[
              rectPos[0],
              rectPos[1]
            ], rectW, rectH, /* tuple */[
              rect2Pos[0],
              rect2Pos[1]
            ], rect2W, rect2H);
}

function draw(state, env) {
  var obstacles = state[/* obstacles */7];
  var foodPosition = state[/* foodPosition */6];
  var snakePrevious = state[/* snakePrevious */5];
  var snake = state[/* snake */4];
  var direction = state[/* direction */2];
  var highScore = state[/* highScore */1];
  var score = state[/* score */0];
  var currentDirection = snakeDirection(direction, env);
  if (Reprocessing_Env.frameCount(env) % 2 === 1) {
    Caml_array.caml_array_get($$Array.of_list(snake), 0);
    Reprocessing_Draw.background(Reprocessing_Utils.color(125, 125, 125, 255), env);
    drawBoundary(env);
    List.iter((function (__x) {
            return drawObstacle(__x, grid, obstacleColor, env);
          }), obstacles);
    drawFood(foodPosition, grid, Reprocessing_Constants.red, env);
    List.iter((function (__x) {
            return drawSnake(__x, grid, headColor, env);
          }), snake);
    drawCenteredSysText("Score: " + String(score), 80, env);
    drawCenteredSysText("High Score: " + String(highScore), 40, env);
    var match = getListElement(0, snake);
    var headY = match[1];
    var headX = match[0];
    var match$1 = getGridPosition(headX, headY, grid);
    var isCollideWithFood = headX === foodPosition[0] && foodPosition[1] === headY;
    var match$2 = hitBoundary(match$1[0], match$1[1], env);
    var boundaryHit = match$2 < 3;
    var match$3 = List.length(snake);
    var selfHit;
    if (match$3 !== 1) {
      var __x = $$Array.of_list(snake);
      selfHit = List.exists((function (el) {
              if (headX === el[0]) {
                return headY === el[1];
              } else {
                return false;
              }
            }), $$Array.to_list($$Array.sub(__x, 1, List.length(snake) - 1 | 0)));
    } else {
      selfHit = false;
    }
    var obstacleHit = List.exists((function (el) {
            if (headX === el[0]) {
              return headY === el[1];
            } else {
              return false;
            }
          }), obstacles);
    var randomObstaclePositions = $$Array.to_list($$Array.map((function () {
                return randomGridPosition(1, 1, 99, 99);
              }), Caml_array.caml_make_vect(obstacleAmount, "")));
    switch (state[/* running */8]) {
      case 0 : 
          var match$4 = boundaryHit || selfHit || obstacleHit;
          return /* record */[
                  /* score */isCollideWithFood ? score + 100 | 0 : score,
                  /* highScore */state[/* highScore */1],
                  /* direction */currentDirection,
                  /* level */state[/* level */3],
                  /* snake */isCollideWithFood ? List.append(snake, /* :: */[
                          getListElement(List.length(snakePrevious) - 1 | 0, snakePrevious),
                          /* [] */0
                        ]) : List.mapi((function (index, position) {
                            var partial_arg = index - 1 | 0;
                            var getEl = function (param) {
                              return getListElement(partial_arg, param);
                            };
                            if (index !== 0) {
                              return moveSnakeGrid(Curry._1(getEl, snakePrevious), directionMoved(Curry._1(getEl, snakePrevious), Curry._1(getEl, snake)));
                            } else {
                              return moveSnakeGrid(position, direction);
                            }
                          }), snake),
                  /* snakePrevious */snake,
                  /* foodPosition */isCollideWithFood ? randomFreeGridPosition(1, 1, 99, 99, obstacles) : foodPosition,
                  /* obstacles */state[/* obstacles */7],
                  /* running */match$4 ? /* Dead */1 : /* Alive */0
                ];
      case 1 : 
          var match$5 = score > highScore;
          return /* record */[
                  /* score */state[/* score */0],
                  /* highScore */match$5 ? score : highScore,
                  /* direction */state[/* direction */2],
                  /* level */state[/* level */3],
                  /* snake */state[/* snake */4],
                  /* snakePrevious */state[/* snakePrevious */5],
                  /* foodPosition */state[/* foodPosition */6],
                  /* obstacles */state[/* obstacles */7],
                  /* running : Restart */2
                ];
      case 2 : 
          return /* record */[
                  /* score */0,
                  /* highScore */state[/* highScore */1],
                  /* direction : None */4,
                  /* level */state[/* level */3],
                  /* snake : :: */[
                    randomGridPosition(1, 1, 99, 99),
                    /* [] */0
                  ],
                  /* snakePrevious */state[/* snakePrevious */5],
                  /* foodPosition */randomGridPosition(1, 1, 99, 99),
                  /* obstacles */randomObstaclePositions,
                  /* running : Alive */0
                ];
      
    }
  } else {
    Reprocessing_Draw.background(Reprocessing_Utils.color(125, 125, 125, 255), env);
    drawBoundary(env);
    List.iter((function (__x) {
            return drawObstacle(__x, grid, obstacleColor, env);
          }), obstacles);
    drawFood(foodPosition, grid, Reprocessing_Constants.red, env);
    List.iter((function (__x) {
            return drawSnake(__x, grid, headColor, env);
          }), snake);
    drawCenteredSysText("Score: " + String(score), 80, env);
    drawCenteredSysText("High Score: " + String(highScore), 40, env);
    return /* record */[
            /* score */state[/* score */0],
            /* highScore */state[/* highScore */1],
            /* direction */currentDirection,
            /* level */state[/* level */3],
            /* snake */state[/* snake */4],
            /* snakePrevious */state[/* snakePrevious */5],
            /* foodPosition */state[/* foodPosition */6],
            /* obstacles */state[/* obstacles */7],
            /* running */state[/* running */8]
          ];
  }
}

Reprocessing.run(setup, undefined, draw, undefined, undefined, undefined, undefined, undefined, undefined, undefined, /* () */0);

var width = 700;

var height = 700;

var frameLock = 2;

var gridLength = 100;

var gridWidth = 100;

var foodColor = Reprocessing_Constants.red;

var speed = 4;

exports.width = width;
exports.height = height;
exports.gridSize = gridSize;
exports.frameLock = frameLock;
exports.gridLength = gridLength;
exports.gridWidth = gridWidth;
exports.bodySize = bodySize;
exports.obstacleAmount = obstacleAmount;
exports.headColor = headColor;
exports.foodColor = foodColor;
exports.obstacleColor = obstacleColor;
exports.textColor = textColor;
exports.speed = speed;
exports.clamp = clamp;
exports.getListElement = getListElement;
exports.hitBoundary = hitBoundary;
exports.printPosition = printPosition;
exports.printGrid = printGrid;
exports.getGridPosition = getGridPosition;
exports.offsetPosition = offsetPosition;
exports.getGridPositionOffset = getGridPositionOffset;
exports.randomGridPosition = randomGridPosition;
exports.randomGridPositionReal = randomGridPositionReal;
exports.randomFreeGridPosition = randomFreeGridPosition;
exports.createGrid = createGrid;
exports.grid = grid;
exports.setup = setup;
exports.snakeDirection = snakeDirection;
exports.moveSnakeGrid = moveSnakeGrid;
exports.directionMoved = directionMoved;
exports.printRunning = printRunning;
exports.drawFood = drawFood;
exports.drawObstacle = drawObstacle;
exports.drawBoundary = drawBoundary;
exports.drawSnake = drawSnake;
exports.drawCenteredText = drawCenteredText;
exports.normalize = normalize;
exports.drawCenteredSysText = drawCenteredSysText;
exports.intersectRectCircleI = intersectRectCircleI;
exports.intersectRectRectI = intersectRectRectI;
exports.draw = draw;
/* obstacleAmount Not a pure module */
